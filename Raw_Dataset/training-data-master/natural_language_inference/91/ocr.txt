arXiv:1603.06021v3 [cs.CL] 29 Jul 2016

A Fast Unified Model for Parsing and Sentence Understanding

Samuel R. Bowman!?** Jon Gauthier*>** Abhinav Rastogi°”

sbowman@stanford. edu

Raghav Gupta’>

rgupta93@stanford. edu

jgauthie@stanford.edu

arastogi@stanford.edu

Christopher D. Manning!*> Christopher Potts'°

manning@stanford.edu

cgpotts@stanford. edu

‘Stanford Linguistics 7*Stanford NLP Group °Stanford AI Lab
*Stanford Symbolic Systems ~°Stanford Electrical Engineering °Stanford Computer Science

Abstract

Tree-structured neural networks exploit
valuable syntactic parse information as
they interpret the meanings of sentences. However, they suffer from two
key technical problems that make them
slow and unwieldy for large-scale NLP
tasks: they usually operate on parsed
sentences and they do not directly support batched computation. We address
these issues by introducing the Stackaugmented Parser-Interpreter Neural Network (SPINN), which combines parsing
and interpretation within a single treesequence hybrid model by integrating treestructured sentence interpretation into the
linear sequential structure of a shift-reduce
parser. Our model supports batched computation for a speedup of up to 25x over
other tree-structured models, and its integrated parser can operate on unparsed
data with little loss in accuracy. We evaluate it on the Stanford NLI entailment task
and show that it significantly outperforms
other sentence-encoding models.

1 Introduction

A wide range of current models in NLP are built
around a neural network component that produces vector representations of sentence meaning (e.g., Sutskever et al., 2014; Tai et al., 2015).
This component, the sentence encoder, is generally formulated as a learned parametric function from a sequence of word vectors to a sentence vector, and this function can take a range
of different forms. Common sentence encoders
include sequence-based recurrent neural network

“The first two authors contributed equally.

i ae _t ory =

the cat sat down

(a) A conventional sequence-based RNN for two sentences.
the old cat ate the cat sat down

ZN oN

‘the oldcat —_ ate the cat sat down

aN

‘the cat sat down

 

the oldcat

/\

old cat
(b) A conventional TreeRNN for two sentences.

Figure 1: An illustration of two standard designs for sentence encoders. The TreeRNN, unlike the sequence-based RNN, requires a substantially different connection structure for each sentence, making batched computation impractical.

models (RNNs, see Figure la) with Long ShortTerm Memory (LSTM, Hochreiter and Schmidhuber, 1997), which accumulate information over the
sentence sequentially; convolutional neural networks (Kalchbrenner et al., 2014; Zhang et al.,
2015), which accumulate information using filters over short local sequences of words or characters; and tree-structured recursive neural networks
(TreeRNNs, Goller and Kiichler, 1996; Socher
et al., 201 1a, see Figure 1b), which propagate information up a binary parse tree.

Of these, the TreeRNN appears to be the principled choice, since meaning in natural language
sentences is known to be constructed recursively
according to a tree structure (Dowty, 2007, 1.a.).
 
  
 
 

stack

+ ae — |
composition

4

transition

 
 

_ tracking

 

buffer

      
 
 
     
 
   

     

the cat

   
 

   
  

the cat composition sat
[= j
tracking a tracking

(a) The SPINN model unrolled for two transitions during the processing of the sentence the cat sat down. ‘Tracking’, ‘transition’, and ‘composition’ are neural network layers. Gray arrows indicate connections which are blocked by a gating function.

f=3

  

buffer

 
   
    

output to model
for semantic task

(b) The fully unrolled SPINN for the cat sat down, with neural network layers omitted for clarity.

Figure 2: Two views of the Stack-augmented Parser-Interpreter Neural Network (SPINN).

TreeRNNs have shown promise (Tai et al., 2015;
Li et al., 2015; Bowman et al., 2015b), but have
largely been overlooked in favor of sequencebased RNNs because of their incompatibility with
batched computation and their reliance on external
parsers. Batched computation—performing synchronized computation across many examples at
once—yields order-of-magnitude improvements
in model run time, and is crucial in enabling neural
networks to be trained efficiently on large datasets.
Because TreeRNNs use a different model structure
for each sentence, as in Figure 1, efficient batching
is impossible in standard implementations. Partly
to address efficiency problems, standard TreeRNN
models commonly only operate on sentences that
have already been processed by a syntactic parser,
which slows and complicates the use of these models at test time for most applications.

This paper introduces a new model to address
both these issues: the Stack-augmented ParserInterpreter Neural Network, or SPINN, shown in
Figure 2. SPINN executes the computations of a
tree-structured model in a linearized sequence, and
can incorporate a neural network parser that produces the required parse structure on the fly. This
design improves upon the TreeRNN architecture
in three ways: At test time, it can simultaneously
parse and interpret unparsed sentences, removing
the dependence on an external parser at nearly no

additional computational cost. Secondly, it supports batched computation for both parsed and unparsed sentences, yielding dramatic speedups over
standard TreeRNNs. Finally, it supports a novel
tree-sequence hybrid architecture for handling local linear context in sentence interpretation. This
model is a basically plausible model of human
sentence processing and yields substantial accuracy gains over pure sequence- or tree-based models.

We evaluate SPINN on the Stanford Natural
Language Inference entailment task (SNLI, Bowman et al., 2015a), and find that it significantly
outperforms other sentence-encoding-based models, even with a relatively simple and underpowered implementation of the built-in parser. We also
find that SPINN yields speed increases of up to
25x over a standard TreeRNN implementation.

2 Related work

There is a fairly long history of work on building
neural network-based parsers that use the core operations and data structures from transition-based
parsing, of which shift-reduce parsing is a variant (Henderson, 2004; Emami and Jelinek, 2005;
Titov and Henderson, 2010; Chen and Manning,
2014; Buys and Blunsom, 2015; Dyer et al., 2015;
Kiperwasser and Goldberg, 2016). In addition,
there has been recent work proposing models designed primarily for generative language modeling tasks that use this architecture as well (Zhang
et al., 2016; Dyer et al., 2016). To our knowledge,
SPINN is the first model to use this architecture
for the purpose of sentence interpretation, rather
than parsing or generation.

Socher et al. (2011a,b) present versions of the
TreeRNN model which are capable of operating
over unparsed inputs. However, these methods require an expensive search process at test time. Our
model presents a much faster alternative approach.

3 Our model: SPINN

3.1 Background: Shift-reduce parsing

SPINN is inspired by shift-reduce parsing (Aho
and Ullman, 1972), which builds a tree structure
over a sequence (e.g., a natural language sentence)
by a single left-to-right scan over its tokens. The
formalism is widely used in natural language parsing (e.g., Shieber, 1983; Nivre, 2003).

A shift-reduce parser accepts a sequence of
input tokens x = (xo,...,Xn-1) and consumes
transitions a = (do,...,a7_1), Where each a; €
{SHIFT, REDUCE} specifies one step of the parsing
process. In general a parser may also generate these transitions on the fly as it reads the tokens. It proceeds left-to-right through a transition sequence, combining the input tokens x incrementally into a tree structure. For any binarybranching tree structure over N words, this requires J = 2N — | transitions through a total of
T + 1 states.

The parser uses two auxiliary data structures:
a stack S of partially completed subtrees and a
buffer B of tokens yet to be parsed. The parser is
initialized with the stack empty and the buffer containing the tokens x of the sentence in order. Let
(S,B) = (@0,x) denote this starting state. It next
proceeds through the transition sequence, where
each transition a; selects one of the two following
operations. Below, the | symbol denotes the cons
(concatenation) operator. We arbitrarily choose to
always cons on the left in the notation below.

sHirT: (S,x | B) — (x |S, B). This operation pops
an element from the buffer and pushes it on
to the top of the stack.

REDUCE: (x | y | S,B) > ((x,y) | S,B). This
Operation pops the top two elements from
the stack, merges them, and pushes the result
back on to the stack.

3.2 Composition and representation

SPINN is based on a shift-reduce parser, but it is
designed to produce a vector representation of a
sentence as its output, rather than a tree as in standard shift-reduce parsing. It modifies the shiftreduce formalism by using fixed length vectors to
represent each entry in the stack and the buffer.
Correspondingly, its REDUCE operation combines
two vector representations from the stack into another vector using a neural network function.

The composition function When a REDUCE operation is performed, the vector representations of
two tree nodes are popped off of the stack and fed
into a composition function, which is a neural network function that produces a representation for a
new tree node that is the parent of the two popped
nodes. This new node is pushed on to the stack.

The TreeLSTM composition function (Tai et al.,
2015) generalizes the LSTM neural network layer
to tree- rather than sequence-based inputs, and it
shares with the LSTM the idea of representing intermediate states as a pair of an active state representation h and a memory representation ¢. Our
version is formulated as:

i o
fil | o ay
(1) f —| oO Weomp h + Deomp
O o é
g tanh

2) @=fo@+fo@+iog
(3) h=60tanh(2)

where o is the sigmoid activation function, © is
the elementwise product, the pairs (h!,é@!) and

(h2, 22) are the two input tree nodes popped off
the stack, and @ is an optional vector-valued input
argument which is either empty or comes from an
external source like the tracking LSTM (see Section 3.3). The result of this function, the pair (h, C),
is placed back on the stack. Each vector-valued
variable listed is of dimension D except é, of the

independent dimension Dyracking.

The stack and buffer The stack and the buffer
are arrays of N elements each (for sentences of up
to N words), with the two D-dimensional vectors
h and 2 in each element.

Word representations We use word representations based on the 300D vectors provided with
GloVe (Pennington et al., 2014). We do not update
these representations during training. Instead, we
use a learned linear transformation to map each input word vector XGlove into a vector pair (h, C) that
is stored in the buffer:

>

h 5 >
(4) 4 = Wwaxclove + Owa

3.3. The tracking LSTM

In addition to the stack, buffer, and composition
function, our full model includes an additional
component: the tracking LSTM. This is a simple
sequence-based LSTM RNN that operates in tandem with the model, taking inputs from the buffer
and stack at each step. It is meant to maintain a
low-resolution summary of the portion of the sentence that has been processed so far, which is used
for two purposes: it supplies feature representations to the transition classifier, which allows the
model to stand alone as a parser, and it additionally
supplies a secondary input ¢ to the composition
function—see (1)—allowing context information
to enter the construction of sentence meaning and
forming what is effectively a tree-sequence hybrid
model.

The tracking LSTM’s inputs (yellow in Figure 2) are the top element of the buffer h} (which
would be moved in a sHIFrT operation) and the top
two elements of the stack h! and h (which would
be composed in a REDUCE operation).

Why a tree-sequence hybrid? Lexical ambiguity is ubiquitous in natural language. Most words
have multiple senses or meanings, and it is generally necessary to use the context in which a word
occurs to determine which of its senses or meanings 1s meant in a given sentence. Even though
TreeRNNs are more effective at composing meanings in principle, this ambiguity can give simpler
sequence-based sentence-encoding models an advantage: when a sequence-based model first processes a word, it has direct access to a state vector that summarizes the left context of that word,
which acts as a cue for disambiguation. In contrast, when a standard tree-structured model first
processes a word, it only has access to the constituent that the word is merging with, which is
often just a single additional word. Feeding a
context representation from the tracking LSTM
into the composition function is a simple and efficient way to mitigate this disadvantage of treestructured models. Using left linear context to dis
ambiguate is also a plausible model of human interpretation.

It would be straightforward to augment SPINN
to support the use of some amount of right-side
context as well, but this would add complexity to
the model that we think is largely unnecessary: humans are very effective at understanding the beginnings of sentences before having seen or heard the
ends, suggesting that it is possible to get by without the unavailable right-side context.

3.4 Parsing: Predicting transitions

For SPINN to operate on unparsed inputs, it needs
to produce its own transition sequence a rather
than relying on an external parser to supply it as
part of the input. To do this, the model predicts
a; at each step using a simple two-way softmax
classifier whose input is the state of the tracking
LSTM:

(5) Pa = softmax(Werans/tracking + Dtrans)

The above model is nearly the simplest viable 1mplementation of a transition decision function. In
contrast, the decision functions in state-of-the-art
transition-based parsers tend to use significantly
richer feature sets as inputs, including features
containing information about several upcoming
words on the buffer. The value heracking is a function of only the very top of the buffer and the top
two stack elements at each timestep.

At test time, the model uses whichever transition (1.€., SHIFT Or REDUCE) is assigned a higher
(unnormalized) probability. The prediction function is trained to mimic the decisions of an external parser. These decisions are used as inputs to
the model during training. For SNLI, we use the
binary Stanford PCFG Parser parses that are included with the corpus. We did not find scheduled
sampling (Bengio et al., 2015)—having the model
use its own transition decisions sometimes at training time—to help.

3.5 Implementation issues

Representing the stack efficiently A naive implementation of SPINN needs to handle a size
O(N) stack at each timestep, any element of which
may be involved in later computations. A naive
backpropagation implementation would then require storing each of the O(N) stacks for a backward pass, leading to a per-example space requirement of O(NTD) floats. This requirement is proAlgorithm 1 The thin stack algorithm

1: function StEep(bufferTop, a, t, S, Q)
2 if a = sHirT then

3 S[t] := bufferTop

4 else if a = REDUCE then

5: right := S[Q.popQ]

6 left := S[O.pop(]

7 S[t] := Compose(left, right)
8

Q.push(t)

hibitively large for significant batch sizes or sentence lengths N. Such a naive implementation
would also require copying a largely unchanged
stack at each timestep, since each SHIFT Or REDUCE
operation writes only one new representation to
the top of the stack.

We propose a space-efficient stack representation inspired by the zipper technique (Huet, 1997)
that we call thin stack. For each input sentence, we
represent the stack with a single T x D matrix S.
Each row S [t] (for 0 < t < T) represents the top of
the actual stack at timestep t. At each timestep we
can SHIFT a new element onto the stack, or REDUCE
the top two elements of the stack into a single element. To shift an element from the buffer to the
top of the stack at timestep t, we simply write it
into the location §$ [t]. In order to perform the REDUCE operation, we need to retrieve the top two elements of the actual stack. We maintain a queue Q
of pointers into S which contains the row indices
of S which are still present in the actual stack. The
top two elements of the stack can be found by using the final two pointers in the queue Q. These
retrieved elements are used to perform the REDUCE
operation, which modifies Q to mark that some
rows of S have now been replaced in the actual
stack. Algorithm | describes the full mechanics of
a stack feedforward in this compressed representation. It operates on the single T x D matrix S and
a backpointer queue Q. Table 1 shows an example
run.

This stack representation requires substantially
less space. It stores each element involved in the
feedforward computation exactly once, meaning
that this representation can still support efficient
backpropagation. Furthermore, all of the updates
to S and Q can be performed batched and in-place
on a GPU, yielding substantial speed gains over
both a more naive SPINN implementation and a
standard TreeRNN implementation. We describe

t S[t] QO; at

0 __ SHIFT
] Spot il SHIFT
2 sat 12 SHIFT
3 down 123 REDUCE
4 (sat down) 14 REDUCE
5 (Spot (sat down)) 5

Table 1: The thin-stack algorithm operating on the
input sequence x = (Spot, sat, down) and the transition sequence shown in the rightmost column.
S[t] shows the top of the stack at each step t. The
last two elements of Q (underlined) specify which
rows t would be involved in a REDUCE operation at
the next step.

speed results in Section 3.7.

Preparing the data At training time, SPINN requires both a transition sequence a and a token sequence x as its inputs for each sentence. The token
sequence is simply the words in the sentence in order. a can be obtained from any constituency parse
for the sentence by first converting that parse into
an unlabeled binary parse, then linearizing it (with
the usual in-order traversal), then taking each word
token as a SHIFT transition and each ‘)’ as a REDUCE
transition, as here:

Unlabeled binary parse: ( ( the cat ) ( sat down ) )
x: the, cat, sat, down

@: SHIFT, SHIFT, REDUCE, SHIFT, SHIFT, REDUCE, REDUCE

Handling variable sentence lengths For any
sentence model to be trained with batched computation, it is necessary to pad or crop sentences
to a fixed length. We fix this length at N = 25
words, longer than about 98% of sentences in
SNLI. Transition sequences a are cropped at the
left or padded at the left with suirrs. Token sequences x are then cropped or padded with empty
tokens at the left to match the number of sHrFTs
added or removed from a, and can then be padded
with empty tokens at the right to meet the desired
length N.

3.6 TreeRNN-equivalence

Without the addition of the tracking LSTM,
SPINN (in particular the SPINN-PI-NT variant,
for parsed input, no tracking) is precisely equivalent to a conventional tree-structured neural network model in the function that it computes, and
 

—e— Thin-stack GPU
= CPU (?)

Feedforward time (sec)

 

 

32 64 «128 256 512 1024 2048

Batch size

Figure 3: Feedforward speed comparison.

therefore it also has the same learning dynamics. In both, the representation of each sentence
consists of the representations of the words combined recursively using a TreeRNN composition
function (in our case, the TreeLSTM function).
SPINN, however, is dramatically faster, and supports both integrated parsing and a novel approach
to context through the tracking LSTM.

3.7 Inference speed

In this section, we compare the test-time speed
of our SPINN-PI-NT with an equivalent TreeRNN
implemented in the conventional fashion and with
a standard RNN sequence model. While the
full models evaluated below are implemented
and trained using Theano (Theano Development
Team, 2016), which is reasonably efficient but
not perfect for our model, we wish to compare
well-optimized implementations of all three models. To do this, we reimplement the feedforward!
of SPINN-PI-NT and an LSTM RNN baseline
in C++/CUDA, and compare that implementation
with a CPU-based C++/Eigen TreeRNN implementation from Irsoy and Cardie (2014), which
we modified to perform exactly the same computations as SPINN-PI-NT.* TreeRNNS like this can
only operate on a single example at a time and are
thus poorly suited for GPU computation.

Each model is restricted to run on sentences of

'We chose to reimplement and evaluate only the feedforward/inference pass, as inference speed is the relevant performance metric for most practical applications.

?The original code for Irsoy & Cardie’s model is available
at https: //github.com/oir/deep-recursive. Our optimized C++/CUDA models and the Theano source code
for the full SPINN are available at https: //github.com/
stanfordnlp/spinn.

30 tokens or fewer. We fix the model dimension
D and the word embedding dimension at 300. We
run the CPU performance test on a 2.20 GHz 16core Intel Xeon E5-2660 processor with hyperthreading enabled. We test our thin-stack implementation and the RNN model on an NVIDIA Titan X GPU.

Figure 3 compares the sentence encoding speed
of the three models on random input data. We observe a substantial difference in runtime between
the CPU and thin-stack implementations that increases with batch size. With a large but practical
batch size of 512, the largest on which we tested
the TreeRNN, our model is about 25~x faster than
the standard CPU implementation, and about 4x
slower than the RNN baseline.

Though this experiment only covers SPINNPI-NT, the results should be similar for the full
SPINN model: most of the computation involved
in running SPINN is involved in populating the
buffer, applying the composition function, and
manipulating the buffer and the stack, with the
low-dimensional tracking and parsing components
adding only a small additional load.

4 NLI Experiments

We evaluate SPINN on the task of natural language inference (NLI, a.k.a. recognizing textual
entailment, or RTE; Dagan et al., 2006). NLI is a
sentence pair classification task, in which a model
reads two sentences (a premise and a hypothesis),
and outputs a judgment of entailment, contradiction, or neutral, reflecting the relationship between
the meanings of the two sentences. Below is an example sentence pair and judgment from the SNLI
corpus which we use in our experiments:

Premise: Girl in a red coat, blue head wrap and jeans is
making a snow angel.

Hypothesis: A girl outside plays in the snow.
Label: entailment

SNLI is a corpus of 570k human-labeled pairs
of scene descriptions like this one. We use the
standard train—test split and ignore unlabeled examples, which leaves about 549k examples for
training, 9,842 for development, and 9,824 for
testing. SNLI labels are roughly balanced, with
the most frequent label, entailment, making up
34.2% of the test set.

Although NLI is framed as a simple three-way
classification task, it is nonetheless an effective
way of evaluating the ability of a model to extract broadly informative representations of senParam.

Initial LR
L2 regularization A

Range

2x 1074-2 x 10°
8 x 10-’-3 x 10°

Transition cost a 0.5—4.0
Embedding transformation dropout 80-95%
Classifier MLP dropout 80-95%
Tracking LSTM size Dyacking 24-128
Classifier MLP layers 1-3

Strategy RNN _— SP.-PI-NT SP.-PI SP.
LOG 5x10° 3x107* 7x10°% 2x10°
LOG 4x 10~° 3x10°° 2x10° 3x10>
LIN — — — 3.9
LIN — 83% 92% 86%
LIN 94% 94% 93% 94%
LOG — — 61 719
LIN 2 2 2 1

Table 2: Hyperparameter ranges and values. Range shows the hyperparameter ranges explored during random search. Strategy indicates whether sampling from the range was uniform, or log-uniform.
Dropout parameters are expressed as keep rates rather than drop rates.

tence meaning. In order for a model to perform reliably well on NLI, it must be able to represent and
reason with the core phenomena of natural language semantics, including quantification, coreference, scope, and several types of ambiguity.

4.1 Applying SPINN to SNLI

Creating a sentence-pair classifier To classify an SNLI sentence pair, we run two copies
of SPINN with shared parameters: one on the
premise sentence and another on the hypothesis
sentence. We then use their outputs (the h states
at the top of each stack at time t = T) to construct
a feature vector Xclassifier for the pair. This feature
vector consists of the concatenation of these two
sentence vectors, their difference, and their elementwise product (following Mou et al., 2016):

>
premise
h
hypothesi
(6) Xclassifier —|> ee
premise — Any pothesis

> >

premise @ py pothesis

This feature vector is then passed to a series of
1024D ReLU neural network layers (1.e., an MLP;
the number of layers is tuned as a hyperparameter), then passed into a linear transformation, and
then finally passed to a softmax layer, which yields
a distribution over the three labels.

The objective function Our objective combines
a cross-entropy objective £, for the SNLI classification task, cross-entropy objectives £7 and L;,
for the parsing decision for each of the two sentences at each step rt, and an L2 regularization term
on the trained parameters. The terms are weighted
using the tuned hyperparameters @ and A:

T-1
(1) Lm =Ly ta SLE + Lh) + All

t=0

Initialization, optimization, and tuning We
initialize the model parameters using the nonparametric strategy of He et al. (2015), with the exception of the softmax classifier parameters, which
we initialize using random uniform samples from
[—0.005, 0.005].

We use minibatch SGD with the RMSProp optimizer (Tieleman and Hinton, 2012) and a tuned
starting learning rate that decays by a factor of
0.75 every 10k steps. We apply both dropout (Srivastava et al., 2014) and batch normalization (Ioffe
and Szegedy, 2015) to the output of the word embedding projection layer and to the feature vectors
that serve as the inputs and outputs to the MLP that
precedes the final entailment classifier.

We train each model for 250k steps in each run,
using a batch size of 32. We track each model’s
performance on the development set during training and save parameters when this performance
reaches a new peak. We use early stopping, evaluating on the test set using the parameters that perform best on the development set.

We use random search to tune the hyperparameters of each model, setting the ranges for search for
each hyperparameter heuristically (and validating
the reasonableness of the ranges on the development set), and then launching eight copies of each
experiment each with newly sampled hyperparameters from those ranges. Table 2 shows the hyperparameters used in the best run of each model.

4.2 Models evaluated

We evaluate four models. The four all use the
sentence-pair classifier architecture described in
Section 4.1, and differ only in the function computing the sentence encodings. First, a singlelayer LSTM RNN (similar to that of Bowman
et al., 2015a) serves as a baseline encoder. Next,
the minimal SPINN-PI-NT model (equivalent to a
Model

Params.

Trans. acc. (%)  Trainacc. (%) Test acc. (%)

Previous non-NN results
— — 99.7 78.2

Lexicalized classifier (Bowman et al., 2015a)

Previous sentence encoder-based NN results

100D LSTM encoders (Bowman et al., 2015a)
1024D pretrained GRU encoders (Vendrov et al., 2016)
300D Tree-based CNN encoders (Mou et al., 2016)

3.5m — 83.4 82.1

Our results

300D LSTM RNN encoders

300D SPINN-PI-NT (parsed input, no tracking) encoders
300D SPINN-PI (parsed input) encoders

300D SPINN (unparsed input) encoders

221k — 84.8 77.6

15m — 98.8 81.4
3.0m — 83.9 80.6
3.4m — 84.4 80.9
3.7m — 89.2 83.2
2.7m 92.4 87.2 82.6

Table 3: Results on SNLI 3-way inference classification. Params. is the approximate number of trained
parameters (excluding word embeddings for all models). Trans. acc. is the model’s accuracy in predicting
parsing transitions at test time. Train and test are SNLI classification accuracy.

TreeLSTM) introduces the SPINN model design.
SPINN-PI adds the tracking LSTM to that design.
Finally, the full SPINN adds the integrated parser.

We compare our models against several baselines, including the strongest published non-neural
network-based result from Bowman et al. (2015a)
and previous neural network models built around
several types of sentence encoders.

4.3 Results

Table 3 shows our results on SNLI. For the full
SPINN, we also report a measure of agreement between this model’s parses and the parses included
with SNLI, calculated as classification accuracy
over transitions averaged across timesteps.

We find that the bare SPINN-PI-NT model performs little better than the RNN baseline, but that
SPINN-PI with the added tracking LSTM performs well. The success of SPINN-PI, which is the
hybrid tree-sequence model, suggests that the treeand sequence-based encoding methods are at least
partially complementary, with the sequence model
presumably providing useful local word disambiguation. The full SPINN model with its relatively weak internal parser performs slightly less
well, but nonetheless robustly exceeds the performance of the RNN baseline.

Both SPINN-PI and the full SPINN significantly outperform all previous sentence-encoding
models. Most notably, these models outperform
the tree-based CNN of Mou et al. (2016), which
also uses tree-structured composition for local feature extraction, but uses simpler pooling techniques to build sentence features in the interest of
efficiency. Our results show that a model that uses
tree-structured composition fully (SPINN) outper
forms one which uses it only partially (tree-based
CNN), which in turn outperforms one which does
not use it at all (RNN).

The full SPINN performed moderately well at
reproducing the Stanford Parser’s parses of the
SNLI data at a transition-by-transition level, with
92.4% accuracy at test time.? However, its transition prediction errors are fairly evenly distributed
across sentences, and most sentences were assigned partially invalid transition sequences that
either left a few words out of the final representation or incorporated a few padding tokens into
the final representation.

4.4 Discussion

The use of tree structure improves the performance of sentence-encoding models for SNLI. We
suspect that this improvement is largely due to the
more efficient learning of accurate generalizations
overall, and not to any particular few phenomena.
However, some patterns are identifiable in the results.

While all four models under study have trouble
with negation, the tree-structured SPINN models
do quite substantially better on these pairs. This
is likely due to the fact that parse trees make the
scope of any instance of negation (the portion of
the sentence’s content that is negated) relatively
easy to identify and separate from the rest of the
sentence. For test set sentence pairs like the one
below where negation (not or n’t) does not appear
in the premise but does appear in the hypothesis,
the RNN shows 67% accuracy, while all three treestructured models exceed 73%. Only the RNN got

’Note that this is scoring the model against automatic
parses, not a human-judged gold standard.
the below example wrong:

Premise: The rhythmic gymnast completes her floor exercise at the competition.

Hypothesis: The gymnast cannot finish her exercise.
Label: contradiction
Note that the presence of negation in the hypothesis is correlated with a label of contradiction in
SNLI, but not as strongly as one might intuit—
only 45% of these examples in the test set are labeled as contradictions.

In addition, it seems that tree-structured models, and especially the tree-sequence hybrid models, are more effective than RNNs at extracting informative representations of long sentences. The
RNN model falls off in test accuracy more quickly
with increasing sentence length than SPINN-PINT, which in turn falls of substantially faster than
the two hybrid models, repeating a pattern seen
more dramatically on artificial data in Bowman
et al. (2015b). On pairs with premises of 20 or
more words, the RNN’s 76.7% accuracy, while
SPINN-PI reaches 80.2%. All three SPINN models labeled the following example correctly, while
the RNN did not:

Premise: A man wearing glasses and a ragged costume is
playing a Jaguar electric guitar and singing with the accompaniment of a drummer.

Hypothesis: A man with glasses and a disheveled outfit is
playing a guitar and singing along with a drummer.
Label: entailment

We suspect that the hybrid nature of the full
SPINN model is also responsible for its surprising ability to perform better than an RNN baseline
even when its internal parser is relatively ineffective at producing correct full-sentence parses. It
may act somewhat like the tree-based CNN, only
with access to larger trees: using tree structure to
build up local phrase meanings, and then using the
tracking LSTM, at least in part, to combine those
meanings.

Finally, as is likely inevitable for models evaluated on SNLI, all four models under study did several percent worse on test examples whose ground
truth label is neutral than on examples of the
other two classes. Entailment—neutral and neutral—contradiction confusions appear to be much
harder to avoid than entailment—contradiction
confusions, where relatively superficial cues might
be more readily useful.

5 Conclusions and future work

We introduce a model architecture (SPINN-PINT) that is equivalent to a TreeLSTM, but an or
der of magnitude faster at test time. We expand
that architecture into a tree-sequence hybrid model
(SPINN-PI), and show that this yields significant
gains on the SNLI entailment task. Finally, we
show that it is possible to exploit the strengths of
this model without the need for an external parser
by integrating a fast parser into the model (as in
the full SPINN), and that the lack of external parse
information yields little loss in accuracy.

Because this paper aims to introduce a general
purpose model for sentence encoding, we do not
pursue the use of soft attention (Bahdanau et al.,
2015; Rocktaschel et al., 2016), despite its demonstrated effectiveness on the SNLI task.* However,
we expect that it should be possible to productively combine our model with soft attention to
reach state-of-the-art performance.

Our tracking LSTM uses only simple, quickto-compute features drawn from the head of the
buffer and the head of the stack. It is plausible that
giving the tracking LSTM access to more information from the buffer and stack at each step would
allow it to better represent the context at each tree
node, yielding both better parsing and better sentence encoding. One promising way to pursue this
goal would be to encode the full contents of the
stack and buffer at each time step following the
method used by Dyer et al. (2015).

For a more ambitious goal, we expect that
it should be possible to implement a variant of
SPINN on top of a modified stack data structure
with differentiable pusH and pop operations (as
in Grefenstette et al., 2015; Joulin and Mikolov,
2015). This would make it possible for the model
to learn to parse using guidance from the semantic representation objective, which currently is
blocked from influencing the key parsing parameters by our use of hard sHiFt/REDUCE decisions.
This change would allow the model to learn to produce parses that are, in aggregate, better suited to
supporting semantic interpretation than those supplied in the training data.

Acknowledgments

We acknowledge financial support from a Google
Faculty Research Award, the Stanford Data Science Initiative, and the National Science Foundation under grant nos. BCS 1456077 and US

4 Attention-based models like Rocktischel et al. (2016),
Wang and Jiang (2016), and the unpublished Cheng et al.
(2016) have shown accuracies as high as 86.3% on SNLI,
but are more narrowly engineered to suit the task and do not
yield sentence encodings.
1514268. Some of the Tesla K40s used for this
research were donated by the NVIDIA Corporation. We also thank Kelvin Guu, Noah Goodman,
and many others in the Stanford NLP group for
helpful comments.

References

Alfred V. Aho and Jeffrey D. Ullman. 1972. The
theory of parsing, translation, and compiling.
Prentice-Hall, Inc.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua
Bengio. 2015. Neural machine translation by
jointly learning to align and translate. In Proc.
ICLR.

Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and
Noam Shazeer. 2015. Scheduled sampling for
sequence prediction with recurrent neural networks. In Proc. NIPS.

Samuel R. Bowman, Gabor Angeli, Christopher
Potts, and Christopher D. Manning. 2015a. A
large annotated corpus for learning natural language inference. In Proc. EMNLP.

Samuel R. Bowman, Christopher D. Manning,
and Christopher Potts. 2015b. Tree-structured
composition in neural networks without treestructured architectures. In Proc. 2015 NIPS
Workshop on Cognitive Computation: Integrating Neural and Symbolic Approaches.

Jan Buys and Phil Blunsom. 2015. Generative incremental dependency parsing with neural networks. In Proc. ACL.

Danqi Chen and Christopher D. Manning. 2014. A
fast and accurate dependency parser using neural networks. In Proc. EMNLP.

Jianpeng Cheng, Li Dong, and Mirella Lapata.
2016. Long short-term memory-networks for
machine reading. arXiv:1601.06733.

Ido Dagan, Oren Glickman, and _ Bernardo
Magnini. 2006. The PASCAL recognising textual entailment challenge. In Machine learning
challenges. Evaluating predictive uncertainty,
visual object classification, and recognising tectual entailment, Springer.

David Dowty. 2007. Compositionality as an empirical problem. In Direct Compositionality,
Oxford Univ. Press.

Chris Dyer, Miguel Ballesteros, Wang Ling,
Austin Matthews, and Noah A. Smith. 2015.

Transition-based dependency parsing with stack
long short-term memory. In Proc. ACL.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros, and Noah A. Smith. 2016. Recurrent neural network grammars. In Proc. NAACL.

Ahmad Emami and Frederick Jelinek. 2005. A
neural syntactic language model. Machine
learning 60(1-3).

Christoph Goller and Andreas Ktichler. 1996.
Learning task-dependent distributed representations by backpropagation through structure. In
Proc. IEEE International Conference on Neural
Networks.

Edward Grefenstette, Karl Moritz Hermann,
Mustafa Suleyman, and Phil Blunsom. 2015.
Learning to transduce with unbounded memory.
In Proc. NIPS.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and
Jian Sun. 2015. Delving deep into rectifiers:
Surpassing human-level performance on ImageNet classification. In Proc. ICCV.

James Henderson. 2004. Discriminative training
of a neural network statistical parser. In Proc.
ACL.

Sepp Hochreiter and Jiirgen Schmidhuber. 1997.
Long short-term memory. Neural computation
9(8).

Gérard Huet. 1997. The zipper. Journal of functional programming 7(5).

Sergey Ioffe and Christian Szegedy. 2015. Batch
normalization: Accelerating deep network
training by reducing internal covariate shift. In
Proc. ICML.

Ozan Irsoy and Claire Cardie. 2014. Deep recursive neural networks for compositionality in
language. In Proc. NIPS.

Armand Joulin and Tomas Mikolov. 2015. Inferring algorithmic patterns with stack-augmented
recurrent nets. In Proc. NIPS.

Nal Kalchbrenner, Edward Grefenstette, and Phil
Blunsom. 2014. A convolutional neural network for modelling sentences. In Proc. ACL.

Eliyahu Kiperwasser and Yoav Goldberg. 2016.
Easy-first dependency parsing with hierarchical
tree LSTMs. arXiv:1603.00375.

Jiwei Li, Minh-Thang Luong, Dan Jurafsky, and
Eudard Hovy. 2015. When are tree structures
necessary for deep learning of representations?
In Proc. EMNLP.

Lili Mou, Men Rui, Ge Li, Yan Xu, Lu Zhang,
Rui Yan, and Zhi Jin. 2016. Natural language
inference by tree-based convolution and heuristic matching. In Proc. ACL.

Joakim Nivre. 2003. An efficient algorithm for
projective dependency parsing. In Proc. IWPT.

Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. GloVe: Global vectors
for word representation. In Proc. EMNLP.

Tim Rocktaéschel, Edward Grefenstette, Karl
Moritz Hermann, Toma’ Koéisky, and Phil
Blunsom. 2016. Reasoning about entailment
with neural attention. In Proc. ICLR.

Stuart M. Shieber. 1983. Sentence disambiguation
by a shift-reduce parsing technique. In Proc.
ACL.

Richard Socher, Cliff C. Lin, Andrew Y. Ng, and
Christopher D. Manning. 2011a. Parsing natural scenes and natural language with recursive
neural networks. In Proc. ICML.

Richard Socher, Jeffrey Pennington, Eric H
Huang, Andrew Y. Ng, and Christopher D.
Manning. 2011b. Semi-supervised recursive
autoencoders for predicting sentiment distributions. In Proc. EMNLP.

Nitish Srivastava, Geoffrey Hinton, Alex
Krizhevsky, Ilya Sutskever, and Ruslan
Salakhutdinov. 2014. Dropout: A simple way
to prevent neural networks from overfitting.
JMLR 15.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le.
2014. Sequence to sequence learning with neural networks. In Proc. NIPS.

Kai Sheng Tai, Richard Socher, and Christopher D. Manning. 2015. Improved semantic
representations from tree-structured long shortterm memory networks. In Proc. ACL.

Theano Development Team. 2016. Theano:
A Python framework for fast computation of
mathematical expressions. arXiv:1605.02688.

Tiymen Tieleman and Geoffrey Hinton. 2012. Lecture 6.5 — RMSProp: Divide the gradient by
a running average of its recent magnitude. In
Neural Networks for Machine Learning, Coursera.

Ivan Titov and James Henderson. 2010. A latent
variable model for generative dependency parsing. In Harry Bunt, Paola Merlo, and Joakim
Nivre, editors, Trends in Parsing Technology,
Springer.

Ivan Vendrov, Ryan Kiros, Sanja Fidler, and
Raquel Urtasun. 2016. Order-embeddings of
images and language. In Proc. ICLR.

Shuohang Wang and Jing Jiang. 2016. Learning
natural language inference with LSTM. In Proc.
NAACL.

Xiang Zhang, Junbo Zhao, and Yann LeCun.
2015. Character-level convolutional networks
for text classification. In Proc. NIPS.

Xingxing Zhang, Liang Lu, and Mirella Lapata.
2016. Top-down tree long short-term memory
networks. In Proc. NAACL.
